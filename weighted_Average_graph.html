<!doctype html>
<html>
<head><title>W.A.G</title></head>
    <body>
    
        <script>
         class PriorityQueue
    {
        constructor()
        {
            this.values = [];
            
        }
        enqueue(val,priority)
        {
            this.values.push({val,priority});
            this.sort();
        };
        dequeue()
        {
            return this.values.shift();
        };
        sort()
        {
            this.values.sort((a,b) => a.priority - b.priority);
        };
    }    
            
            
        class Weighted_Average
        {
            constructor()
            {
                this.adjacency = {}
            }
            addVertex(vertex)
            {
                if(!this.adjacency[vertex])
                {
                    this.adjacency[vertex] = [];
                }
            }
            addEdge(vertex1,vertex2,weight)
            {
                this.adjacency[vertex1].push({node:vertex2,weight});
                this.adjacency[vertex2].push({node:vertex1,weight});
            }
            
            Dijkstra(start,finish)
            {
                const nodes = new PriorityQueue();
                const distances = {};
                const previous = {};
                let path = [];
                let smallest;
                //build up initial state
                for(let vertex in this.adjacency)
                {
                    if(vertex === start)
                    {
                        distances[vertex] = 0;
                        nodes.enqueue(vertex,0);
                    }else
                        {
                            distances[vertex] = Infinity;
                            nodes.enqueue(vertex,Infinity);
                        }
                    previous[vertex] = null;
                }
                //as long as there is something to visit
                while(nodes.values.length)
                      {
                        smallest = nodes.dequeue().val;
                        if(smallest === finish)
                        {
                            //we are done
                            //build up path to return to
                            while(previous[smallest])
                            {
                                path.push(smallest);
                                smallest = previous[smallest];
                            }
                            break;
                        }
                          
                          if(smallest || distances[smallest] !== Infinity)
                          {
                              for(let neighbor in this.adjacency[smallest])
                              {
                                  let nextNode = this.adjacency[smallest][neighbor];
                                  
                                  let candidate = distance[smallest] + nextNode.weight;
                                  
                                  let nextNeighbor = nextNode.node
                                  
                                  if(candidate < distances[nextNeighbor])
                                  {
                                      distances[nextNeighbor] = candidate;
                                      
                                      previous[nextNeighbor] = smallest;
                                      
                                      nodes.enqueue(nextNeighbor,candidate);
                                  }
                              }
                          }
                      }
                return path.conct(smallest).reverse()
            }
        }
            
        let g = new Weighted_Average();
        </script>
    </body>
</html>